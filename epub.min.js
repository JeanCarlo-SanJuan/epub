import EventEmitter from"events";import*as zip from"@zip.js/zip.js";import convert from"xml-js";import toArray from"./toArray.js";import removeChildsWithTags from"./removeChildsWithTags.js";import RootPath from"./RootPath.js";export const ev={root:"parsed-root",manifest:"parsed-manifest",spine:"parsed-spine",flow:"parsed-flow",toc:"parsed-toc",metadata:"parsed-metadata",err:"error",loaded:"loaded"};export class Epub extends EventEmitter{constructor(file,chapterTransformer){super(),this.file={archive:file,container:!1,mime:!1,root:!1},this.metadata={},this.manifest={},this.spine={toc:!1,contents:[]},this.flow=new Map,this.toc=new Map,this.chapterTransformer=chapterTransformer,this.cache={text:{},setText(id,t){this.text[id]=t},image:{},setImage(id,blob){this.image[id]=blob}}}error(msg){this.emit(ev.err,new Error(msg))}errorMIME(name){this.error("Invalid mimetype for: "+name)}async open(events={}){this.reader=new zip.ZipReader(new zip.BlobReader(this.file.archive));for(const[name,cb]of Object.entries(events))this.on(name,cb.bind(this));this.entries=await this.reader.getEntries(),await this.reader.close(),this.entries?this.checkMimeType():this.error("No files in archive")}getFileInArchive(name){for(const entry of this.entries){if(entry.directory)continue;"/"==name[0]&&(name=name.slice(1));const eFN=entry.filename.toLowerCase(),fn=name.toLowerCase();if(eFN.includes(fn)||fn.includes(eFN))return entry}this.error(name+" not found in archive!")}determineWriter(w){switch(w){case"text":return new zip.TextWriter;case"blob":return new zip.BlobWriter}}async getFileContents(name,writer="text"){const f=this.getFileInArchive(name),w=this.determineWriter(writer);return{file:f,data:await f.getData(w)}}async checkMimeType(){const{file:file,data:data}=await this.getFileContents("mimetype");this.file.mime=file,"application/epub+zip"!=data&&this.error("Unsupported mime type"),this.getRootFiles()}async getRootFiles(){this.file.container=await this.getFileContents("meta-inf/container.xml");const{container:container}=this.xml2js(this.file.container.data.toString("utf-8").toLowerCase().trim());container.rootfiles&&container.rootfiles.rootfile||this.error("No rootfiles found");const{"full-path":fullPath,"media-type":mediaType}=container.rootfiles.rootfile._attributes;"application/oebps-package+xml"!=mediaType&&this.errorMIME(fullPath),this.file.rootName=fullPath,this.rootPath=new RootPath(fullPath),this.handleRootFile()}xml2js(data){return convert.xml2js(data,{compact:!0,spaces:4})}async handleRootFile(){const{data:data}=await this.getFileContents(this.file.rootName);this.rootXML=this.xml2js(data),this.emit("parsed-root")}async parseRootFile({package:pkg}){this.version=pkg._attributes.version||"2.0",this.metadata=this.parseMetadata(pkg.metadata),this.emit(ev.metadata),this.manifest=this.parseManifest(pkg.manifest),this.emit(ev.manifest),this.spine=this.parseSpine(pkg.spine,this.manifest),this.emit(ev.spine),this.flow=this.parseFlow(this.spine.contents),this.emit(ev.flow),this.toc=await this.parseTOC(this.manifest,this.spine.toc),this.emit(ev.toc),this.emit(ev.loaded)}parseManifest(_manifest){const manifest={};for(const item of _manifest.item){const elem=item._attributes;elem.href=this.rootPath.alter(elem.href),elem.id=elem.id.replace(".","_"),manifest[(elem.id+"").replace(".","_")]=elem}return manifest}parseSpine(_spine,manifest){const spine=Object.assign(this.spine,_spine._attributes);if(_spine.itemref){_spine.itemref=toArray(_spine.itemref);for(const{_attributes:_attributes}of _spine.itemref){const element=Object.assign({},manifest[_attributes.idref.replace(".","_")]);element.id=element.id.replace(".","_"),spine.contents.push(element)}}return spine}parseFlow(contents){const flow=new Map;return contents.map(item=>flow.set(item.id,item)),flow}extractUUID(txt){if("string"==typeof txt){let parts=(txt=txt.toLowerCase()).split(":");if(parts.includes("uuid"))return parts[parts.length-1]}return""}parseMetadata(_metadata){const metadata={};for(const[k,v]of Object.entries(_metadata)){const keyparts=k.split(":"),key=(keyparts[keyparts.length-1]||"").toLowerCase().trim(),text=""+v._text;switch(key){case"creator":Array.isArray(v)?metadata.creator=v.map(item=>item._text).join(" | "):metadata.creator=text;break;case"identifier":Array.isArray(v)?metadata.UUID=this.extractUUID(v[0]._text):"ISBN"==v["opf:scheme"]?metadata.ISBN=text:metadata.UUID=this.extractUUID(text);break;default:metadata[key]=text}}return metadata}async parseTOC(manifest,_toc){const hasNCX=Boolean(_toc);let toc,tocElem;console.log("has NCX:",hasNCX),tocElem=manifest[hasNCX?_toc:"toc"];const IDs={};for(const[k,v]of Object.entries(manifest))IDs[v.href]=k;const{data:data}=await this.getFileContents(tocElem.href);data||this.error("No TOC!!!");const xml=this.xml2js(data);if(hasNCX){const path=tocElem.href.split("/");path.pop(),toc=this.walkNavMap({branch:xml.ncx.navMap.navPoint,path:path,IDs:IDs},manifest)}else toc=this.walkTOC(xml.html.body,manifest);return this.matchTOCWithManifest(toc,manifest)}matchTOCWithManifest(toc,manifest){for(const[id,elem]of toc){if(elem.href.includes(id))continue;let href;elem.href.includes("#")&&([href]=elem.href.trim().split("#",1));for(const key in manifest)if(href==manifest[key].href){elem.id=key;break}}return toc}walkTOC(body,manifest){let order=0;const toc=new Map;for(const p of body.p){let _id=p._attributes.id;_id=_id.replace(".","_").replace(/toc(-|:)/i,"").trim();let title=p.a._text;if(!manifest[_id])continue;const element=manifest[_id];element.title=title,element.order=order++,element.id=element.id.replace(".","_"),toc.set(_id,element)}return console.log("OPF",toc),toc}walkNavMap({branch:branch,path:path,IDs:IDs,level:level=0},manifest){if(level>7)return[];const output=new Map;for(const part of toArray(branch)){if(!part)continue;let title="";part.navLabel&&(title=(part.navLabel.text._text||part.navLabel).trim());let order=Number(part._attributes.playOrder||0);isNaN(order)&&(order=0);let href=part.content._attributes.src;"string"==typeof href&&(href=href.trim());let element={level:level,order:order,title:title};href&&(element.href=path.concat([href]).join("/"),IDs[element.href]?(element=manifest[IDs[element.href]],element.title=title,element.order=order,element.level=level,element.id=element.id.replace(".","_"),element.navPoint=!!part.navPoint&&this.walkNavMap({branch:part.navPoint,path:path,IDs:IDs,level:level+1},manifest)):element.id=(part._attributes.id||"").trim(),output.set(element.id,element))}return output}async getContent(id){if(Object.keys(this.cache.text).includes(id))return this.cache.text[id];let str=await this.getContentRaw(id);str=str.replace(/\r?\n/g,"\0"),str.replace(/<body[^>]*?>(.*)<\/body[^>]*?>/i,(o,d)=>{str=d.trim()});const frag=document.createElement("div");frag.innerHTML=str,removeChildsWithTags(frag,"script","style");const onEvent=/^on.+/i;for(const elem of frag.querySelectorAll("*"))for(const{name:name}of elem.attributes)onEvent.test(name)&&elem.removeAttribute(name);for(const a of frag.querySelectorAll("a")){a.href=a.href.replace(/\.x?html?.+/,"").replace(/(t|T)ext\//,"#");const _id=a.hash.slice(1);for(const k in this.manifest)if(k.includes(_id)){a.href="#"+k;break}}for(const svg of frag.querySelectorAll("svg")){const image=svg.querySelector("image");if(!image)continue;const img=new Image;img.dataset.src=image.getAttribute("xlink:href"),svg.parentNode.replaceChild(img,svg)}for(const img of frag.querySelectorAll("img")){const src=this.rootPath.alter(img.src||img.dataset.src);img.dataset.src=src;for(const _id in this.manifest)src==this.manifest[_id].href&&(img.src=await this.getImage(_id))}return"function"==typeof this.chapterTransformer&&(str=this.chapterTransformer(frag).innerHTML),this.cache.setText(id,str),str}async getContentRaw(id){if(!this.manifest[id])return"";const allowedMIMETypes=/^(application\/xhtml\+xml|image\/svg\+xml)$/i,elem=this.manifest[id];let match;return allowedMIMETypes.test(elem["media-type"])||this.errorMIME("chapter - "+id),(await this.getFileContents(elem.href)).data}async getImage(id){if(this.cache.image[id])return this.cache.image[id];const item=this.manifest[id]||null;if(null==item)return"";const imageType=/^image\//i;let match;if(!imageType.test(item["media-type"].trim()))return console.log("Warning: Invalid mime type for image: "+id),"";const{data:data}=await this.getFileContents(item.href,"blob"),r=new FileReader;return new Promise((resolve,reject)=>{r.onload=e=>{this.cache.setImage(id,e.target.result),resolve(e.target.result)},r.onerror=()=>reject(r.error),r.readAsDataURL(data)})}hasDRM(){const drmFile="META-INF/encryption.xml";return Object.keys(this.entries).includes(drmFile)}}export default Epub;