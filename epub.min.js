import EventEmitter from"events";import*as zip from"@zip.js/zip.js";import convert from"xml-js";import toArray from"./toArray.js";import removeChildsWithTags from"./removeChildsWithTags.js";import simplifyHTMLTree from"./simplifyHTMLTree.js";import RootPath from"./RootPath.js";class Epub extends EventEmitter{constructor(file){super(),this.file={archive:file,container:!1,mime:!1,root:!1},this.metadata={},this.manifest={},this.spine={toc:!1,contents:[]},this.flow=new Map,this.toc=new Map,this.cache={text:{},setText(id,t){this.text[id]=t},image:{},setImage(id,blob){this.image[id]=blob}}}error(msg){this.emit("error",new Error(msg))}async open(){this.reader=new zip.ZipReader(new zip.BlobReader(this.file.archive)),this.entries=await this.reader.getEntries(),await this.reader.close(),this.entries?this.checkMimeType():this.error("No files in archive")}getFileInArchive(name){for(const entry of this.entries){if(entry.directory)continue;"/"==name[0]&&(name=name.slice(1));const eFN=entry.filename.toLowerCase(),fn=name.toLowerCase();if(eFN.includes(fn)||fn.includes(eFN))return entry}this.error(name+" not found in archive!")}determineWriter(w){switch(w){case"text":return new zip.TextWriter;case"blob":return new zip.BlobWriter}}async getFileContents(name,writer="text"){const f=this.getFileInArchive(name),w=this.determineWriter(writer);return{file:f,data:await f.getData(w)}}async checkMimeType(){const{file:mimeFile,data:txt}=await this.getFileContents("mimetype");this.file.mime=mimeFile,"application/epub+zip"==txt?this.getRootFiles():this.error("Unsupported mime type")}async getRootFiles(){this.file.container=await this.getFileContents("meta-inf/container.xml");const{data:data}=this.file.container,{container:container}=this.xml2js(data.toString("utf-8").toLowerCase().trim());if(!container.rootfiles||!container.rootfiles.rootfile)return void this.error("No rootfiles found");const rootFile=container.rootfiles.rootfile,{"full-path":fullPath,"media-type":mediaType}=rootFile._attributes;"application/oebps-package+xml"!=mediaType&&this.error("Invalid mime type for "+fullPath),this.file.rootName=fullPath,this.rootPath=new RootPath(fullPath),this.handleRootFile()}xml2js(data){return convert.xml2js(data,{compact:!0,spaces:4})}async handleRootFile(){const{data:data}=await this.getFileContents(this.file.rootName),xml=this.xml2js(data);this.rootXML=xml,this.emit("parsed-root")}async parseRootFile({package:pkg}){this.version=pkg._attributes.version||"2.0",this.metadata=this.parseMetadata(pkg.metadata),this.emit("parsed-metadata"),this.manifest=this.parseManifest(pkg.manifest),this.emit("parsed-manifest"),this.spine=this.parseSpine(pkg.spine,this.manifest),this.emit("parsed-spine"),this.parseFlow(this.spine.contents),this.emit("parsed-flow"),this.toc=await this.parseTOC(this.manifest,this.spine.toc),this.emit("parsed-toc"),this.emit("loaded")}parseManifest(_manifest){const manifest={};for(const item of _manifest.item){const element=item._attributes;element.href=this.rootPath.alter(element.href),manifest[element.id]=element}return manifest}parseSpine(_spine,manifest){const spine=Object.assign(this.spine,_spine._attributes);if(_spine.itemref){_spine.itemref=toArray(_spine.itemref);for(const{_attributes:_attributes}of _spine.itemref){const element=Object.assign({},manifest[_attributes.idref]);spine.contents.push(element)}}return spine}parseFlow(contents){contents.map(item=>{this.flow.set(item.id,item)})}extractUUID(txt){if("string"==typeof txt){let parts=(txt=txt.toLowerCase()).split(":");if(parts.includes("uuid"))return parts[parts.length-1]}return""}parseMetadata(_metadata){const metadata={};for(const[k,v]of Object.entries(_metadata)){const keyparts=k.split(":"),key=(keyparts[keyparts.length-1]||"").toLowerCase().trim(),text=""+v._text;switch(key){case"publisher":metadata.publisher=text;break;case"language":metadata.language=text;break;case"title":metadata.title=text;break;case"subject":metadata.subject=text;break;case"description":metadata.description=text;break;case"creator":Array.isArray(v)?metadata.creator=v.map(item=>item._text).join(" | "):metadata.creator=text;break;case"date":metadata.date=text;break;case"identifier":Array.isArray(v)?metadata.UUID=this.extractUUID(v[0]._text):"ISBN"==v["opf:scheme"]?metadata.ISBN=text:metadata.UUID=this.extractUUID(text)}}return metadata}async parseTOC(manifest,_toc){const hasNCX=Boolean(_toc);let toc,tocElem;console.log("has NCX:",hasNCX),tocElem=manifest[hasNCX?_toc:"toc"];const IDs={};for(const[k,v]of Object.entries(manifest))IDs[v.href]=k;const{data:data}=await this.getFileContents(tocElem.href);data||this.error("No TOC!!!");const xml=this.xml2js(data);if(hasNCX){const path=tocElem.href.split("/");path.pop(),toc=this.walkNavMap({branch:xml.ncx.navMap.navPoint,path:path,IDs:IDs},manifest)}else toc=this.walkTOC(xml.html.body,manifest);return this.matchTOCWithManifest(toc,manifest)}matchTOCWithManifest(toc,manifest){for(const[id,elem]of toc){if(elem.href.includes(id))continue;let href;elem.href.includes("#")&&([href]=elem.href.trim().split("#",1));for(const key in manifest)if(href==manifest[key].href){elem.id=key;break}}return toc}walkTOC(body,manifest){let order=0;const toc=new Map;for(const p of body.p){let _id=p._attributes.id;_id=_id.replace(/toc(-|:)/i,"").trim();let title=p.a._text;if(!manifest[_id])continue;const element=manifest[_id];element.title=title,element.order=order++,toc.set(_id,element)}return console.log("OPF",toc),toc}walkNavMap({branch:branch,path:path,IDs:IDs,level:level=0},manifest){if(level>7)return[];const output=new Map;for(const part of toArray(branch)){if(!part)continue;let title="";part.navLabel&&(title=(part.navLabel.text._text||part.navLabel).trim());let order=Number(part._attributes.playOrder||0);isNaN(order)&&(order=0);let href=part.content._attributes.src;"string"==typeof href&&(href=href.trim());let element={level:level,order:order,title:title};href&&(element.href=path.concat([href]).join("/"),IDs[element.href]?(element=manifest[IDs[element.href]],element.title=title,element.order=order,element.level=level,element.navPoint=!!part.navPoint&&this.walkNavMap({branch:part.navPoint,path:path,IDs:IDs,level:level+1},manifest)):element.id=(part._attributes.id||"").trim(),output.set(element.id,element))}return output}async getContent(id){if(Object.keys(this.cache.text).includes(id))return this.cache.text[id];let str=await this.getContentRaw(id);str=str.replace(/\r?\n/g,"\0"),str.replace(/<body[^>]*?>(.*)<\/body[^>]*?>/i,(o,d)=>{str=d.trim()});const frag=document.createElement("div");frag.innerHTML=str,removeChildsWithTags(frag,"script","style");const onEvent=/^on.+/i;for(const elem of frag.querySelectorAll("*"))for(const{name:name}of elem.attributes)onEvent.test(name)&&elem.removeAttribute(name);for(const a of frag.querySelectorAll("a"))a.href=a.href.replace(/\.x?html?.+/,"").replace(/(t|T)ext\//,"#");for(const svg of frag.querySelectorAll("svg")){const image=svg.querySelector("image");if(!image)continue;const img=new Image;img.dataset.src=image.getAttribute("xlink:href"),svg.parentNode.replaceChild(img,svg)}for(const img of frag.querySelectorAll("img")){const src=this.rootPath.alter(img.src||img.dataset.src);img.src="";for(const{id:id,href:href}of Object.values(this.manifest))href==src&&(img.src=await this.getImage(id))}return str=simplifyHTMLTree(frag).innerHTML,this.cache.setText(id,str),str}async getContentRaw(id){if(!this.manifest[id])return"";const allowedMIMETypes=/^(application\/xhtml\+xml|image\/svg\+xml)$/i,elem=this.manifest[id];let match;return allowedMIMETypes.test(elem["media-type"])||this.error("Invalid mime type for chapter"),(await this.getFileContents(elem.href)).data}async getImage(id){if(!this.manifest[id])return null;if(this.cache.image[id])return this.cache.image[id];const imageType=/^image\//i,m=this.manifest[id]["media-type"];let match;if(!imageType.test(m.trim()))return console.log("Warning: Invalid mime type for image: "+id),"";const{data:b}=await this.getFileContents(this.manifest[id].href,"blob"),r=new FileReader;return new Promise((resolve,reject)=>{r.onload=e=>{this.cache.setImage(id,e.target.result),resolve(e.target.result)},r.onerror=()=>reject(r.error),r.readAsDataURL(b)})}hasDRM(){const drmFile="META-INF/encryption.xml";return Boolean(this.getFileInArchive(drmFile))}}export default Epub;